# mysql基础知识

#### 1. 数据库有那几个隔离级别？ (2_2024_02_25)

1. 读未提交，存在胀读、不可重复读、幻读
2. 读已提交，不可重复读、幻读
3. 可重复读，可重复读 + 间隙锁 解决 大部分幻读问题
4. 串行化，无问题

#### 2. 什么是脏读、不可重复读、幻读？ (2_2024_02_25)
脏读: 能读到其他事物还未提交的数据 (其他事物可能会回滚)

不可重复读: 一个事物内，同一条数据在不通查询中返回的结果不一样

幻读: 一个事物内不同的查询时间点，对同一条件的查询，返回的结果集不同


#### 3. 什么是两类丢失?  (2_2024_02_25)
第一类丢失: 回滚操作覆盖其他事物提交的数据
第二类丢失: 提交操作覆盖其他事物提交的数据

解决方案:
1. 悲观锁: 加互斥锁 select for update (并发量较大)
2. 乐关锁: 加版本号 （并发量较小）

#### 4. 什么是当前读和快照读？  (2_2024_02_25)

当前读: 读取记录的最新版本，select in share mod，select for udpate，select for delete， update、insert、delete 这些操作都会触发一次当前读

快照读: 就是根据事物的Read View去读取当前事物id可见的记录，普通的select语句触发快照读



#### 5. 记录有那三个隐藏字段？  (2_2024_02_25)
1. DB_ROW_ID， 6B 隐藏的自增ID，如果表没有主键以及唯一键来生成聚簇索引，就会使用DB_ROW_ID来生成聚簇索引
2. DB_TRX_ID，6B 事物ID，表示最后一次修改/删除这条记录的事物ID
3. BD_ROLL_PTR，7B，指向该记录的上一个版本(存储在undo日志里面)的指针

#### 6. 简介一下undo.log日志？  (2_2024_02_25)

undo.log 日志分为两种分别是 insert undo log和update undo log

insert undo log: 代表事物在insert新记录时产生的undo log，只有在会滚的时候需要，事物提交即可丢弃

update undo log: 事物在修改或者删除时产生，不仅在事物会滚时需要，在快照读时也需要，所以不能随机删除，只有在快照读和事物都不涉及该日志时，对应的日志才会被删除


当我们修改一条记录的时候，会对该记录施加一个x锁，然后把记录拷贝到update undo log中，然后修改该行的DB_TRX_ID为当前事物ID，DB_ROLL_PTR指向上一个版本，提交后释放锁，
这样该记录会形成一个版本链条，头部是最新的版本，尾部是最老的版本


#### 7. mysql 是如何实现事物的隔离级别的？  (2_2024_02_25)
mysql 通过mvcc来实现事物隔离级别，mvcc是一种多版本控制方法，数据库的并发场景有一下三种:
1. 读读，无并发问题
2. 读写，脏读，不可重复读和幻读问题
3. 写写，第一类丢失和第二类丢失问题

MVCC主要是用来解决读写问题的，写写问题可以通过乐关锁或者悲观锁来实现。MVCC的实现主要是依赖 记录的三个隐藏字段、undo日志以及Read View 读视图


#### 8. 什么是读视图？  (2_2024_02_25)

Read View是在事物进行快照读的时候产生的，在事物进行快照读的那一刻，会产生一个数据库的快照，记录并维护当前数据库活跃的事物ID(事物ID严格递增)

#### 9. Read View的可见性算法是怎么样的？  (2_2024_02_25)
Read View是用来做可见性判断的，其遵循一个可见性算法，我可以简单的理解其内部维护了三个属性

1. trx_list，一个数值列表，当前活跃的事物ID
2. min_trx_id，trx_list 最小的一个事物ID
3. max_trx_id，Read View生成时刻，系统已分配的最大事物id
4. creator_trx_id, 生成该快照的事物id

首先比较记录的DB_TRX_ID是否小于min_trx_id，如果小于的话，则表示该条记录在创建Read View的时候就已经提交了，所以是可见的

然后比较记录的DB_TRX_ID是否大于max_trx_id，如果大于的话则表示记录被创建Read View之后的新的事务所修改，所以对当前事务不可见

如果记录的DB_TRX_Id在trx_list当中，并且DB_TRX_ID不等于当前的事务id，则表示其他事务修改了当前记录，并且还尚未提交，所以对当前事务是不可见的，如果DB_TRX_ID等于当前事务的id的话，那么对当前事务是可见的。

如果记录的DB_TRX_ID大于min_trx_id小于max_trx_id的话并且不在trx_list当中的话，那么表示修改该记录的事务在Read View之前就已经提交了，所以对当前事务是可见的。


#### 10. MVCC在隔离级别是可重复读时，是如何解决脏读和不可重复读的？  (2_2024_02_25)













参考资料:
1. [ ] [数据库第一类第二类丢失更新](https://blog.csdn.net/paopaopotter/article/details/79259686)

