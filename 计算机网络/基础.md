# 计算机网络基础知识

#### 1. http 请求报文格式？ (3_2024_12_10)
http请求报文包含三部分，请求行(请求方法、URL、版本)、请求头、空行，请求体

![image](https://github.com/Luozujian/architect/assets/27532970/27d26b3d-49f8-4986-9835-320e8d57e331)


#### 2. http 响应报文格式？ (3_2024_12_10)
http 响应报文格式包含状态码(协议版本，状态吗，描述)，响应头，空行，响应体

```c++
HTTP/1.1 200 OK
```

#### 3. http 常见的请求方式？ (3_2024_12_10)
1. OPTIONS，1. 用于查看特定资源所支持的HTTP方法， 2.CORS的预检请求(检查是否支持跨域)
2. HEAD，和GET请求一样，不返回响应体，获取响应头
3. GET，常用于获取服务器上的数据，应该设计成幂等
4. PUT，常用于向服务器更新数据，具体业务
5. POST，常用于向服务器提交数据，应该是非幂等的
6. DELETE，常用于向服务器删除数据，具体业务
7. TRACE，回显服务器收到的请求，常用于测试或诊断
8. CONNET,用于连接代理服务器

#### 4. http常见的请求头？ (3_2024_12_10)
1. Host， 当前请求访问的目标地址(主机:端口)
2. Refer, 从那个地址来的
3. User-Agent, 客户端类型
4. Cookie，cookie信息
5. Connection， close/keep-alive 服务器和客户端的连接状态，close表示关闭，keep-alive 保持连接

#### 5.  Get 和 Post的区别？ (3_2024_12_10)
分三种常见去作答。

在游览器的HTTP请求，而非Ajax的HTTP请求中，GET表示用来获取一个HTML页面/图片等资源，而POST是用来提交form表单的.

1. GET 请求把参数放在url上面，而游览器对url的长度有限制，因而GET请求不能用来发送大量数据
2. GET 请求把数据拼接在url上，post请求把参数放在body中里面，安全性get没有post好
3. URL只支持ASCII编码，而BODY支持任意编码
4. GET是可缓存，幂等的，而POST是不可缓存，非幂等的
5. GET请求当服务器返回302时会触发重定向，而POST请求不会

在ajax请求当中
1. GET请求可以把参数放在请求体里面，也可以放在请求头上，无硬性规定
2. GET可以走游览器缓存


在后端与后端交互中：
1. GET请求和POST请求几乎没有区别，编程规范要求，get请求用户获取资源，post请求用于提交数据

#### 6. 常见的http 请求状态码？    (3_2024_12_10)
1. 100，服务器已经接收大部分请求，客户端可以继续发送剩下的请求
2. 101，(切换协议) 请求者要求服务器切换协议，并且服务器已经准备切换
3. 2xx: 表示成功处理了请求
4. 200，(已成功) 服务器成功处理了请求，通常表示服务器成功提供了网页数据
5. 201，(已创建) 请求成功，服务器已创建新的资源
6. 202，(已接收) 服务器接收了请求，但是尚未处理
7. 3xx，重定向
8. 301，(永久移动)，请求的地址已永久移动到一个新的地址，服务器返回针对GET或者HEAD的请求时会自动将请求移动到新的位置(post请求不会重定向)
9. 302，(临时重定向)，请求地址已永久移动到一个新的地址
10. 4xx，请求错误
11. 400，请求错误，服务器不理解请求的语法
12. 401，未授权，需要进行登录认证
13. 403，禁止访问，服务器拒绝访问
14. 404，资源不存在
15. 5xx 服务器错误
16. 500，服务器内部错误，无法完成请求

#### 7. 如何理解HTTP协议时无状态的？  (3_2024_12_10)
在http协议的设计中服务器并不会保存客户端任何的状态信息，每一次客户端和服务器的交互都是独立的，好处简化设计、高可用、可拓展，但是在实际应用中，需要维护用户的
会话状态，比如登录、个性化内容等。

#### 8. 介绍一下HTTP请求的长连接、短连接？  (3_2024_12_10)
短连接: 完成一次HTTP请求交互，链接立马关闭的是短连接
长连接: 完成一次HTTP请求交互，连接继续保持的是长连接

在HTTP1.0中，默认使用的是短连接，短连接意味着每次客户端向服务器发送数据都需要建立一次HTTP连接，然后数据发送完成之后断开连接。

再HTTP1.1中，默认使用的就是长连接了，长连接在数据发送完成之后，连接会继续保持一段时间，后续的请求，无需再经过HTTP三次握手，提升了交互效率

#### 9. 短连接 & 长连接适用的场景？ (3_2024_12_10)
短连接虽然带宽利用率低、但是他无需服务器维护连接状态，服务器相关资源消耗较少，而长连接虽然带宽利用率高，但是需要服务器维护长连接状态，
如果客户端很多，会消耗服务器较多资源，影响服务器性能。

因此：
1. 客户较少，交互频繁的场景可以使用长连接
2. 客户较多，交互不频繁的场景，可以使用短连接


#### 10. http1.1 相比 http 1.0做的优化？  (3_2024_12_10)
1. http1.0 需要显示的指定使用长连接，而http1.1 默认就是使用长连接
2. http1.1 引入range字段，可以实现断点续传功能
3. Http1.1 支持更多的缓存控制策略，比如Entity Tag/If-None-Match, Last-Modify/Unmodified-Since(断点续传)，Entity Tag/If-Match等策略
4. Http1.1 还支持了更多的响应码，比如409（资源状态冲突），410(资源已经被删除等)

#### 11. http2 和 http1.x的区别？  (3_2024_12_10)
1. http1.x 是基于文本解析的，而http2.x是基于二进制解析的，健壮性更强
2. header压缩，http2.x 支持对header进行压缩传输
3. http2.x 支持io多路复用，即允许多个请求使用同一个连接并行进行请求，接收方根据帧所属流的标识进行组织
4. http2.x支持服务器主动向客户端推送数据，可以解析html依赖的js文件，主动向客户端推送


#### 12. TCP与UDP的区别？(3_2024_12_20)

|        | TCP     | UDP  |
|  ----  | ----    |----  |
| 可靠性  | 可靠     |不可靠 |
| 连接性  | 面向连接  |面向无连接 |
| 报文  | 二进制流  |面向报文 |
| 效率  | 效率高  |效率低 |
| 双工性  | 全双工  |一对一，一对多，多对一，多对多 |
| 流量控制  | 有(滑动窗口)  |无 |
| 拥塞控制  | 有(拥塞避免，慢开始，快重传，开恢复)  |无 |
| 使用场景  | 对效率要求低，但是对准确性要求高，或者是要求有连接的场景  |对效率要求高，对准确性要求没那么高的场景 |
| 示例  | FTP一般用于文件传输，文字传输 | 而UDP协议一般用于语音通话，视频聊天，这类丢失一些数据也并不影响通话，视频的一个整体效果 |



#### 13. osi 7层网络模型？(3_2024_12_20)

- 物理链路层：网络设备如何组成可用网络相关技术
- 数据链路层: 数据路线规划，流量控制，数据矫正，MAC地址
- 网络层：IP，负责网络与网络之间的路由
- 传输层：TCP/UCP，传输具体方式定义
- 会话层：建立连接，关闭连接
- 表示层：为上层提供基础能力，TSL，SSL
- 应用层：FTP，HTTP，SMTP,POP等等

参考资料：https://www.freecodecamp.org/chinese/news/osi-model-networking-layers/

#### 14. 长连接的保活机制? (2_2024_04_17)



#### 15. https为什么是安全的？ (3_2024_12_10)
非对称加解 + 对称加密 + CA证书保证安全性同时兼顾效率

HTTP明文传输容易出现中间人攻击，导致数据泄露，从而导致不可预估的影响

HTTPS通过如下交互流程，避免中间人攻击，大致如下

1. 客户端请求服务端获取CA证书，CA证书主要包含域名、有效日期，公钥，所有者名称等相关信息，以及证书数据摘要和对摘要的签名字符串
2. 客户端内置CA机构公钥，中间人也能获取到CA机构公钥，用于解密第一次请求的相应内容，但是他无法更改，因为公钥加密后，客户端公钥无法解密，他也可以利用自己申请的CA证书做替换，但是会因为证书域名与所请求域名不同，导致客户端报风险
3. 客户端利用CA公钥验证签名，然后随机生成对称加密秘钥，然后利用公钥对秘钥进行加密传输到服务端，服务端拿到加密字符串后，用私钥进行解密
4. 后续通信双方就用对称加密串进行加密通信

整个交互流程兼顾安全与效率

#### 16.






#### 参考资料:
1. [ ] [二进制协议和文本协议的区别](https://blog.csdn.net/qq_40771473/article/details/106003171)
