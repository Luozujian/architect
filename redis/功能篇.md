### 功能篇
#### 1. redis有几种过期键删除策略？(3_2024_12_15)
1. 定时删除，过期时间一到，立马删除，过期键多时容易阻塞用户情趣，产生慢查，导致连锁反应，产生雪崩，优点是: 内存不会存在大量过期键
2. 懒惰删除，在用到时检验是否过期，过期即删除，不用花大量时间去删除过期键，内存存在很多过期键
3. 定期删除，每隔一段时间执行一次过期键删除策略，默认是100ms，每次执行时间较短，最长不会超过25ms。


#### 2. 定期删除如何实现？ (3_2024_12_15)
通过配置确定每秒执行次数默认10次，以及每次最长执行时长25ms，然后每次随机选择20个key，如果过期key的占比超过25%则继续抽查，
否则结束本轮抽查，如果抽查时长超过25ms，则强制结束。

redis4.0 已经支持异步删除了


#### 8. 如果不设置最大内存会怎么样？ (3_2024_12_15)
不进行内存检查，哪怕超过了机器的内存也不管，直到实例崩溃

#### 9. redis的内存淘汰策略有几种? (3_2024_12_15)
   8种，可以分为不进行数据淘汰和进行数据淘汰，不进行数据淘汰是默认策略，内存达到上限之后，不允许写入。
进行数据淘汰:
1. 过期键 => lru，random，ttl，lfu
2. 所有键 => lru，random，lfu

#### 10. LRU和LFU有什么区别？ (3_2024_12_15)
LRU: Least Recently Used，最近最少使用，很久不用了，还被使用的概率就很低，就可以进行淘汰
LFU: Least Frequently Used，最近最不常用，用于解决LRU的缓存污染问题，就一下子读了很多数据，导致之前常用的数据背舍弃

LFU：使用时间不连续，但是使用频率较高的数据，比如热点数据


#### 11. redis是如何实现LRU的？ (3_2024_12_15)
redisObject有一个最近访问时间的字段，redis 并没有实现一个严格的LRU，因为实现一个严格的LRU需要很大的额外空间，redis实现的是近似LRU，当需要进行内存淘汰的时候，随机抽取部分key，按照最近访问时间排序，然后删除


#### 12. lfu是如何实现的？  (3_2024_12_15)
lfu是服用lru记录时间的字段，用16位来记录时间，8位来记录热度值，然后按照热度值来排序，进行淘汰。




参考资料:
1. [ ] [Redis 过期删除策略和内存淘汰策略有什么区别？](https://www.xiaolincoding.com/redis/module/strategy.html#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5)
