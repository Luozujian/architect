#### 1. golang基础语法
##### 1.1 make和new的区别？(6_2023_11_20)
new: new可以为任意类型变量分配内存空间，并返回一个指针，不进行初始化动作

make: make只能为slice、channel以及map分配内存空间，返回引用，并执行初始化动作
 
##### 1.2 指针和引用的区别？(6_2023_11_20)
指针: 指针在初始化的时候指向某一个地址，后续还可以指向新的地址

引用: 引用在初始化的时候指向某一个地址，后续无法在指向新的地址，对引用的修改，会直接修改引用所对应变量的值

##### 1.3 什么是深拷贝，什么是浅拷贝？(6_2023_11_20)
深拷贝: 复制出一个全新的对象，该对象有自己的内存空间，和原对象不共享内存,避免内存逃逸，增加GC压力,增加复制对象的开销

浅拷贝: 复制出一个新的指针，该指针和原指针指向同一块内存地址,减少复制对象的开销，缺点，增加内存逃逸风险，增加GC压力

##### 1.4 传指针还是传对象？(6_2023_11_20)
如果对象不大, 并且我不希望下游函数改变对象的值的话，就会传对象，避免内存逃逸，增加GC压力

如果对象比较大，或者我希望下游函数改变对象的值，就会传指针，减少大对象深拷贝的开销

##### 1.5 golang 切片和数组的区别？(6_2023_11_20)
数组: 维护同一种类型数据的集合，值类型，大小不可变

slice: 维护同一种类型数据的集合，引用类型，具备动态扩容机制，底层由数组实现

##### 1.6 切片的扩容机制? (6_2023_11_20)
1.18以前，当所需容量大于当前容量的两倍，扩容到所需容量的两倍，当原来容量少于1024，则直接扩容当前容量的两倍，当原来容量大于1024，则每次扩容原容量的1.25倍直到满足所需容量

那么就会有一个问题，当容量大于1024的时候是直接扩容两倍，当容量小于1024的时候就变成1.25倍了，不太平滑

于是在golang1.18的时候，切片的扩容机制就换了一种算法，当原容量大于256的时候，让扩容系数随着长度的增加而变小，具体系数的变化范围在(2～1.25)之间。

具体公式是: newCap = oldCap + (oldcap + 3 * thread) / 4



##### 1.7 golang什么时候会panic? (6_2023_11_20)
常见的有10种:
1. 空指针异常
2. 向未初始化的map插入数据
3. 向未初始化的channel里面发数据
4. 关闭未初始化的channel
5. 重复关闭channel
6. 死锁
7. 向channel里面发数据，但是不从channel收数据
8. 并发读写map
9. 递归死循环，堆栈溢出
10. 数组越界
11. 断言错误
![panic常见场景](https://github.com/Luozujian/architect/assets/27532970/70623f7c-4add-40fc-a825-ba818182ca9d)


##### 1.8 什么是内存对齐？ (6_2023_11_20)
内存对齐是用来优化CPU的执行效率的，CPU读取内存数据，不是一个字节一个字节的读取的，在32位的操作系统是一次读取4个字节，在64位的操作系统一次读取8个字节，如果不内存对齐的就会发生一个问题，读取一个变量，可能需要读取多次，使得CPU的执行效率降低。


##### 1.10 内存对齐是如何解决以上问题的呢？ (5_2023_11_20)
两条规则: 64位机器对齐系数是8
1. 结构体变量: 对齐系数为默认对齐系数和变量长度较小值的整数倍
2. 结构体本身: 对齐系数为默认对其系数和结构体字段最大对齐系数取其中较小值

##### 1.11 内存对齐的好处？ (6_2023_11_20)
优点:
1. 优化CPU读取内存数据的性能

缺点:
1. 浪费内存，典型的空间换时间，不过现在内存相比之前更加便宜了




##### 问题TODO:
1. 堆分配内存开销，和栈分配内存开销


##### 参考资料:
1. [ ] [1.切片扩容机制](https://juejin.cn/post/7101928883280150558)
2. [ ] [2.内存对齐](https://geektutu.com/post/hpg-struct-alignment.html)
3. [ ] [3.内存对齐=>煎鱼](https://eddycjy.gitbook.io/golang/di-1-ke-za-tan/go-memory-align)
 

