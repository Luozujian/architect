#### 1. golang基础语法
##### 1.1 make和new的区别？(3_2023_09_18)
new: new可以为任意类型变量分配内存空间，并返回一个指针，不进行初始化动作
make: make只能为slice、channel以及map分配内存空间，返回引用，并执行初始化动作

##### 1.2 指针和引用的区别？(3_2023_09_18)
指针: 指针在初始化的时候指向某一个地址，后续还可以指向新的地址
引用: 引用在初始化的时候指向某一个地址，后续无法在指向新的地址，对引用的修改，会直接修改引用所对应变量的值

##### 1.3 什么是深拷贝，什么是浅拷贝？(3_2023_09_18)
深拷贝: 复制出一个全新的对象，该对象有自己的内存空间，和原对象不共享内存,避免内存逃逸，增加GC压力,增加复制对象的开销
浅拷贝: 复制出一个新的指针，该指针和原指针指向同一块内存地址,减少复制对象的开销，缺点，增加内存逃逸风险，增加GC压力

##### 1.4 传指针还是传对象？(3_2023_09_18)
如果对象不大, 并且我不希望下游函数改变对象的值的话，就会传对象，避免内存逃逸，增加GC压力
如果对象比较大，或者我希望下游函数改变对象的值，就会传指针，减少大对象深拷贝的开销

##### 1.5 golang 切片和数组的区别？(3_2023_09_18)
数组: 维护同一种类型数据的集合，值类型，大小不可变
slice: 维护同一种类型数据的集合，引用类型，具备动态扩容机制，底层由数组实现

#### 1.6 切片的扩容机制? (3_2023_09_18)
1.18以前，当所需容量大于当前容量的两倍，扩容到所需容量的两倍，当原来长度少于1024，则直接扩容当前容量的两倍，当原来长度大于1024，则每次扩容原容量的1.25倍直到满足所需容量

那么就会有一个问题，当长度大于1024的时候是直接扩容两倍，当容量小于1024的时候就变成1.25倍了，不太平滑

于是在golang1.18的时候，切片的扩容机制就换了一种算法，当原长度大于256的时候，让扩容系数随着长度的增加而变小，具体系数的变化范围在(2～1.25)之间。

具体公式是: newCap = oldCap + (oldcap + 3 * thread) / 4







##### 1.1 golang什么时候会panic? (2_2023_09_13)
常见的有10种:
1. 空指针异常
2. 向未初始化的map插入数据
3. 向未初始化的channel里面发数据
4. 关闭未初始化的channel
5. 重复关闭未初始化的channel
6. 死锁
7. 向channel里面发数据，但是不从channel收数据
8. 并发读写map
9. 递归死循环，堆栈溢出
10. 数组越界
![panic常见场景](https://github.com/Luozujian/architect/assets/27532970/70623f7c-4add-40fc-a825-ba818182ca9d)



##### 问题TODO:
1. 栈上GC原理？
2. 堆分配内存开销，和栈分配内存开销
3. 

##### 参考资料:
1. [ ] [1.切片扩容机制](https://juejin.cn/post/7101928883280150558)


