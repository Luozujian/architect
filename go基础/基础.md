#### 1. golang与其他语言比较
##### 1.1 什么是面向对象 (2_2024_10_09)
根据wikipedia给出的定义，面向对象编程是一种基于类&实例的编程范式，类是抽象的模版，实例是基于类创建出的对象，实例拥有相同的方法，拥有不同的数据。计算机程序可视为一组对象的集合，而每个对象都可以接收其他对象发过来消息并处理，计算机程序的执行就是一系列消息在对象之间的流转。

其具备以下三个重要特性：封装、继承、多态


##### 1.2 什么是封装、继承、多态 (2_2024_10_09)

* 封装，隐藏对象内部属性与属性操作相关实现细节，仅对外提供公开接口调用操作属性，用户无需关系接口实现细节 & 增强对象健壮性

  ```js
  go语言，结构体中属性首字母小写表示私有资源，无法被外部所访问，大写表示公共资源，可以被外部所访问，
  可以使用首字母小写搭配相应的set和get方法，实现封装

  首字母大小写用于判断对其他包是否可见，无法做到完全杜绝直接操作属性，封装具有局限性
  
  type Animal struct {
    name string
  }
  
  func NewAnimal() *Animal {
       return &Animal{}
  }
  
  func (p *Animal) SetName(name string) {
       p.name = name
  }
  
  func (p *Animal) GetName() string {
       return p.name
  }
  
  ```
* 继承，子类继承父类的属性与方法，使得子类与父类具备某些相同的特征与行为
  ![image](https://github.com/user-attachments/assets/bb932904-53e6-4fbe-b367-e92da9506fa2)

  ```js
  type Animal struct {
     Name string
  }
  
  type Cat struct {
       Animal
       FeatureA string
  }
  
  type Dog struct {
       Animal
       FeatureB string
  }
  
  func main() {
       p := NewAnimal()
       p.SetName("我是搬运工，去给煎鱼点赞~")
  
       dog := Dog{Animal: *p}
       fmt.Println(dog.GetName())
  }

  ```

* 多态，指的是对象在不同情形下，有不同的表现形式，其使得不同结构的对象可以共享相同的外部接口只需要满足接口的定义即可
  ```
  type AnimalSounder interface {
     MakeDNA()
  }
  
  func MakeSomeDNA(animalSounder AnimalSounder) {		// 参数是AnimalSounder接口类型
       animalSounder.MakeDNA()
  }

  func (c *Cat) MakeDNA() {
     fmt.Println("煎鱼是煎鱼")
  }
  
  func (c *Dog) MakeDNA() {
       fmt.Println("煎鱼其实不是煎鱼")
  }
  
  func main() {
       MakeSomeDNA(&Cat{})
       MakeSomeDNA(&Dog{})
  }
  ```

##### 1.3 面向对象设计的5大编程原则？(2_2024_10_09)
* 单一职责，每个类被修改的动机，有且只有一个，对类的职责要有一个清晰的定义，对文件、目录、模块、团队都要有一个清晰的定义，明确职责范围内的事情
* 


https://blog.csdn.net/Taobaojishu/article/details/114313082


#### 1. golang基础语法
##### 1.1 make和new的区别？(6_2023_11_20)
new: new可以为任意类型变量分配内存空间，并返回一个指针，不进行初始化动作

make: make只能为slice、channel以及map分配内存空间，返回引用，并执行初始化动作



##### 1.2 指针和引用的区别？(6_2023_11_20)
指针: 指针在初始化的时候指向某一个地址，后续还可以指向新的地址

引用: 引用在初始化的时候指向某一个地址，后续无法在指向新的地址，对引用的修改，会直接修改引用所对应变量的值

##### 1.3 什么是深拷贝，什么是浅拷贝？(6_2023_11_20)
深拷贝: 复制出一个全新的对象，该对象有自己的内存空间，和原对象不共享内存,避免内存逃逸，增加GC压力,增加复制对象的开销

浅拷贝: 复制出一个新的指针，该指针和原指针指向同一块内存地址,减少复制对象的开销，缺点，增加内存逃逸风险，增加GC压力

##### 1.4 传指针还是传对象？(6_2023_11_20)
如果对象不大, 并且我不希望下游函数改变对象的值的话，就会传对象，避免内存逃逸，增加GC压力

如果对象比较大，或者我希望下游函数改变对象的值，就会传指针，减少大对象深拷贝的开销

##### 1.5 golang 切片和数组的区别？(6_2023_11_20)
数组: 维护同一种类型数据的集合，值类型，大小不可变

slice: 维护同一种类型数据的集合，引用类型，具备动态扩容机制，底层由数组实现

##### 1.6 切片的扩容机制? (6_2023_11_20)
1.18以前，当所需容量大于当前容量的两倍，扩容到所需容量的两倍，当原来容量少于1024，则直接扩容当前容量的两倍，当原来容量大于1024，则每次扩容原容量的1.25倍直到满足所需容量

那么就会有一个问题，当容量大于1024的时候是直接扩容两倍，当容量小于1024的时候就变成1.25倍了，不太平滑

于是在golang1.18的时候，切片的扩容机制就换了一种算法，当原容量大于256的时候，让扩容系数随着长度的增加而变小，具体系数的变化范围在(2～1.25)之间。

具体公式是: newCap = oldCap + (oldcap + 3 * thread) / 4



##### 1.7 golang什么时候会panic? (6_2023_11_20)
常见的有10种:
1. 空指针异常
2. 向未初始化的map插入数据
3. 向未初始化的channel里面发数据
4. 关闭未初始化的channel
5. 重复关闭channel
6. 死锁
7. 向channel里面发数据，但是不从channel收数据
8. 并发读写map
9. 递归死循环，堆栈溢出
10. 数组越界
11. 断言错误
![panic常见场景](https://github.com/Luozujian/architect/assets/27532970/70623f7c-4add-40fc-a825-ba818182ca9d)


##### 1.8 什么是内存对齐？ (6_2023_11_20)
内存对齐是用来优化CPU的执行效率的，CPU读取内存数据，不是一个字节一个字节的读取的，在32位的操作系统是一次读取4个字节，在64位的操作系统一次读取8个字节，如果不内存对齐的就会发生一个问题，读取一个变量，可能需要读取多次，使得CPU的执行效率降低。


##### 1.10 内存对齐是如何解决以上问题的呢？ (5_2023_11_20)
两条规则: 64位机器对齐系数是8
1. 结构体变量: 对齐系数为默认对齐系数和变量长度较小值的整数倍
2. 结构体本身: 对齐系数为默认对其系数和结构体字段最大对齐系数取其中较小值

##### 1.11 内存对齐的好处？ (6_2023_11_20)
优点:
1. 优化CPU读取内存数据的性能

缺点:
1. 浪费内存，典型的空间换时间，不过现在内存相比之前更加便宜了




##### 问题TODO:
1. 堆分配内存开销，和栈分配内存开销


##### 参考资料:
1. [ ] [1.切片扩容机制](https://juejin.cn/post/7101928883280150558)
2. [ ] [2.内存对齐](https://geektutu.com/post/hpg-struct-alignment.html)
3. [ ] [3.内存对齐=>煎鱼](https://eddycjy.gitbook.io/golang/di-1-ke-za-tan/go-memory-align)
 

