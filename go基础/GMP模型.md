### GMP模型
#### 1. goroutine相对线程而言的优点？(3_2023_10_31)
1. 启动占用的空间小，只需要2KB的栈空间，而内核线程起码是M级别
2. 工作在用户态，切换开销小



#### 2. 内核线程、进程与Goroutine(用户线程)的区别？ (3_2023_10_31)
1. 进程是资源分配的基本单位，线程是系统调度的基本单位
2. 用户线程必须绑定内核线程才能被运行，内核线程才是调度的基本单位，内核感知不到用户线程的存在



#### 3. 有几种线程模型？(3_2023_10_31)
3种，分别是用户线程:内核线程 1 : 1, n : 1 以及 n : m



#### 4. 3中线程模型的优缺点？(3_2023_10_31)
```c++
第一种: N:1
优点:
1. 实现简单
缺点:
1. 内核线程阻塞，整个应用程序都会阻塞
2. 无法利用多核提速

第二种: 1:1
优点:
1. 可以利用多核提速
缺点:
1. 用户态线程切换意味着内核线程切换，开销较大

第三种: N:M
优点:
1. 可以利用多核提速
2. 不存在以为某个内核线程阻塞，而导致整个应用程序阻塞的情况
3. 不会因为用户线程切换，而导致内核线程切换，带来较大的开销
缺点:
1. 实现复杂
```


#### 5. GMP模型中每个字母的意义分别是啥？ (3_2023_10_31)
G: 即Goroutine，参与调度的最小单位
M: 内核线程
P: 逻辑处理器，其绑定了一个本地可运行的G队列，称为LRQ队列，最多可存放256个G

GMP模型还包含一些其他的关键数据结构，比如全局的G队列，空闲的M队列以及空闲的P队列

#### 6. 执行go func做的事情？ (3_2023_10_31)
1. 创建一个G，优先加入到当前P所对应的本地队列，如果本地队列满了则加入到全局队列

#### 7. M和P，M和G的关系？(3_2023_10_31)
G只能运行在M上，M必须绑定P。M从P弹出一个可执行的G来执行，如果P本地队列无可执行的G，优先从全局G队列中取G，如果没有则从其他队列中取数据。
// 单独这个问题有点奇怪

#### 8. 如果M阻塞了会怎么样？ (3_2023_10_31)
阻塞系统调用: 如果M阻塞了，会将M和G剥离，P再创建一个新的M继续执行，当M和G唤醒后，M和G会尝试找一个空闲的P，如果没有，则M加入到空闲的M队列，G加入到全局队列。
非阻塞系统调用: M和G唤醒后，优先看之前的P还能不能绑定上，如果绑不上，则M加入到空闲的M队列，G加入到全局队列


#### 9. 什么是M0，G0? (3_2023_10_31)
M0: 启动进程后创建编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责创建第一个G，之后和其他M一样。
G0: 每次启动一个M第一个创建的Goroutine就是G0，每个M都有自己的G0，G0负责调度，不执行具体的函数。

// M0具体做了啥，串不起来
// 

#### 10. 启动golang进程的大概逻辑？ (2_2023_10_30)
1. 创建m0、g0，并且将两者关联
2. 初始化P的个数
3. 执行main函数的代码，创建一个G，加入到P的本地队列
4. 启动m0，从P中获取G，执行
5. M运行G，G运行完，M继续从P的本地队列获取G，直到main.main退出。

#### 11. P上面的G切换是怎么样的流程？(2_2023_10_30)
G1运行完成 => G0 => G2继续执行

#### 12. 如果P本地队列满了，再往里面加数据会怎么样？ (2_2023_10_30)
把本地队列前一半的数据，加上新创建的都放到全局队列当中去

#### 13. 创建G的时候会干嘛？  (2_2023_10_30)
创建G的时候会尝试唤醒休眠的M和P组合，这个时候M是运行状态，但是P的本地队列没有G，这个时候M就是自选线程

#### 14. 优先从全局队列偷还是优先从其他本地队列中偷？ (2_2023_10_30)
优先从全局队列偷: n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))
然后从其他本地队列偷: 偷后一半，work stealing


#### 15. 系统中最多有多少个自旋线程？  (2_2023_10_30)
GOMAXPROCS个

#### 16. golang程序是如何启动的？ (2_2023_10_30)
1. 在启动的时候，首先会执行各种初始化动作，调度器、内存分配器、GC等等工作
2. 然后会创建一个M0以及其所对应的G0,并且M0将它和P绑定起来
3. 然后创建一个Goroutine指向main.main方法，将该Goroutine放入到M0所对应的P
4. 然后运行M0，开始执行调度



参考资料:
1. [ ] [GMP模型](https://go.cyub.vip/gmp/gmp-model/)
2. [ ] [Golang 调度器 GMP 原理与调度全分析](https://learnku.com/articles/41728)
3. [ ] [详解 Go 程序的启动流程，你知道 g0，m0 是什么吗？](https://segmentfault.com/a/1190000040181868)
4. [ ] [聊聊 g0](https://studygolang.com/articles/28384)
