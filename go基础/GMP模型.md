### GMP模型


#### 1. 什么是GM模型？ (2_2023_11_13)
golang在1.1之前



#### 1. goroutine相对线程而言的优点？(4_2023_11_13)
1. 启动占用的空间小，只需要2KB的栈空间，而内核线程起码是M级别
2. 工作在用户态，切换开销小



#### 2. 内核线程、进程与Goroutine(用户线程)的区别？ (4_2023_11_13)
1. 进程是资源分配的基本单位，线程是系统调度的基本单位
2. 用户线程必须绑定内核线程才能被运行，内核线程才是调度的基本单位，内核感知不到用户线程的存在



#### 3. 有几种线程模型？(4_2023_11_13)
3种，分别是用户线程:内核线程 1 : 1, n : 1 以及 n : m



#### 4. 3中线程模型的优缺点？(4_2023_11_13)
```c++
第一种: N:1
优点:
1. 实现简单
缺点:
1. 内核线程阻塞，整个应用程序都会阻塞
2. 无法利用多核提速

第二种: 1:1
优点:
1. 可以利用多核提速
缺点:
1. 用户态线程切换意味着内核线程切换，开销较大

第三种: N:M
优点:
1. 可以利用多核提速
2. 不存在以为某个内核线程阻塞，而导致整个应用程序阻塞的情况
3. 不会因为用户线程切换，而导致内核线程切换，带来较大的开销
缺点:
1. 实现复杂
```


#### 5. GMP模型中每个字母的意义分别是啥？ (4_2023_11_13)
G: 即Goroutine，参与调度的最小单位  
M: 内核线程
P: 逻辑处理器，其绑定了一个本地可运行的G队列，称为LRQ队列，最多可存放256个G

GMP模型还包含一些其他的关键数据结构，比如全局的G队列，空闲的M队列以及空闲的P队列

#### 6. 执行go func做的事情？ (4_2023_11_13)
1. 创建一个G，优先加入到当前P所对应的本地队列，如果本地队列满了则加入到全局队列

#### 7. M和P，M和G的关系？(4_2023_11_13)
G只能运行在M上，M必须绑定P。M从P弹出一个可执行的G来执行，如果P本地队列无可执行的G，优先从全局G队列中取G，如果没有则从其他队列中取数据。
// 单独这个问题有点奇怪

#### 8. 如果M阻塞了会怎么样？ (4_2023_11_13)
阻塞系统调用: 如果M阻塞了，会将M和G剥离，P再创建一个新的M继续执行，当M和G唤醒后，M和G会尝试找一个空闲的P，如果没有，则M加入到空闲的M队列，G加入到全局队列。
非阻塞系统调用: M和G唤醒后，优先看之前的P还能不能绑定上，如果绑不上，则M加入到空闲的M队列，G加入到全局队列


#### 9. 什么是M0，G0? (4_2023_11_13)
M0: 启动进程后创建编号为0的主线程，一个Goroutine只有一个M0线程，从数据结构上看和其他M也没啥区别，和功能上看
G0: 每次创建M的时候同时也会创建G0，用于执行调度任务，和普通G的不同之处在于其栈空间固定8M并且不可扩所容，而普通G的栈空间大小2KB。

// M0具体做了啥，串不起来
// 

#### 10. P上面的G切换是怎么样的流程？(4_2023_11_13)
G1运行完成 => G0 => G2继续执行

#### 11. 如果P本地队列满了，再往里面加数据会怎么样？ (4_2023_11_13)
把本地队列前一半的数据，加上新创建的G打散，都放到全局队列当中去

#### 12. 创建G的时候会干嘛？  (4_2023_11_13)
当前有空闲的P，则唤醒或者创建M与之绑定，如果M是运行状态，但是所对应P的本地队列没有G，则属于自旋线程

#### 13. 优先从全局队列偷还是优先从其他本地队列中偷？ (4_2023_11_13)
优先从全局队列偷: n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))
然后从其他本地队列偷: 偷后一半，work stealing


#### 14. 系统中最多有多少个自旋线程？  (4_2023_11_13)
GOMAXPROCS个

#### 16. golang程序是如何启动的？ (3_2023_11_13)
1. 在启动的时候，首先会执行各种初始化动作，调度器、内存分配器、GC等等工作
2. 然后会创建一个M0以及其所对应的G0,并且M0将它和P绑定起来
3. 然后创建一个Goroutine指向main.main方法，将该Goroutine放入到M0所对应的P
4. 然后运行M0，开始执行调度

#### 17. 有那几种情况会创建M? (3_2023_11_13)
1. 程序启动的时候，会创建第一个主线程M0
2. 当G从waiting状态变成running状态的时候，如果有空闲的P，则会看是否有空闲的M如果没有则创建一个M与之绑定，并运行
3. M进去系统调用的时候，如果P的本地队列还有数据的话，则P会尝试获取一个空闲的M或者创建一个M与之绑定，继续运行




参考资料:
1. [ ] [GMP模型](https://go.cyub.vip/gmp/gmp-model/)
2. [ ] [Golang 调度器 GMP 原理与调度全分析](https://learnku.com/articles/41728)
3. [ ] [详解 Go 程序的启动流程，你知道 g0，m0 是什么吗？](https://segmentfault.com/a/1190000040181868)
4. [ ] [聊聊 g0](https://studygolang.com/articles/28384)
5. [ ] [Golang GPM 模型剖析](https://www.cnblogs.com/cxt618/p/15785845.html)
