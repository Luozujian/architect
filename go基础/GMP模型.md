### GMP模型
#### 1. goroutine相对线程而言的优点？(2_2023_10_30)
1. 启动占用的空间小，只需要2KB的栈空间
2. 可自动扩容，最大可到GB级别
3. 工作在用户态，切换开销小
4. 与线程的关系是n:m，即n个内核线程可调度m个Goroutine


#### 2. 内核线程、进程与Goroutine(用户线程)的区别？ (2_2023_10_30)
1. 进程是资源分配的基本单位，进程是系统调度的基本单位
2. 用户线程必须绑定内核线程才能允许，内核线程才是调度的基本单位，内核感知不到用户线程的存在


#### 3. 有几种线程模型？(2_2023_10_30)
3种，分别是用户线程:内核线程 1 : 1, n : 1 以及 n : m

#### 4. 3中线程模型的优缺点？(2_2023_10_30)
```c++
第一种: 1:1 
优点:
1. 实现简单，线程的创建、销毁、切换工作都是有内核完成的，应用程序完全不参与线程管理
缺点:
1. 当该应用程序对应的内核线程被阻塞，整个进程都将阻塞

第二种: N:1
优点:
1.
缺点:
1. 当某个用户线程出现阻塞的操作，可进行切换给其他线程运行，但是当内核线程阻塞的时候，整哥应用也将阻塞

第三种: N:M
优点:
1. 不会因为某一个内核线程阻塞，而导致整个进程阻塞
```


#### 5. GMP模型中每个字母的意义分别是啥？ (2_2023_10_30)
G: 即Goroutine，参与调度的最小单位
M: 内核线程
P: 逻辑处理器，其绑定了一个本地可运行的G队列，称为LRQ队列，最多可存放256个G

#### 6. 执行go func做的事情？ (2_2023_10_30)
1. 创建一个G，优先加入到当前P所对应的本地队列，如果本地队列满了则加入到全局队列

#### 7. M和P，M和G的关系？(2_2023_10_30)
G只能运行在M上，M必须绑定P。M从P弹出一个可执行的G来执行，如果P本地队列无可执行的G，则从其他P对应的本地偷G

#### 8. 如果M阻塞了会怎么样？ (2_2023_10_30)
如果M阻塞了，会将M和G剥离，P再创建一个新的M继续执行，当M和G唤醒后，M和G会尝试找一个空闲的P，如果没有，则M加入到空闲的M队列，G加入到全局队列。

#### 9. 什么是M0，G0? (2_2023_10_30)
M0: 启动进程后创建编号为0的主进程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责创建第一个G，之后和其他M一样。
G0: 每次启动一个M第一个创建的Goroutine就是G0，每个M都有自己的G0，G0负责调度，不执行具体的函数。

#### 10. 启动golang进程的大概逻辑？ (2_2023_10_30)
1. 创建m0、g0，并且将两者关联
2. 初始化P的个数
3. 执行main函数的代码，创建一个G，加入到P的本地队列
4. 启动m0，从P中获取G，执行
5. M运行G，G运行完，M继续从P的本地队列获取G，直到main.main退出。

#### 11. P上面的G切换是怎么样的流程？(2_2023_10_30)
G1运行完成 => G0 => G2继续执行

#### 12. 如果P本地队列满了，再往里面加数据会怎么样？ (2_2023_10_30)
把本地队列前一半的数据，加上新创建的都放到全局队列当中去

#### 13. 创建G的时候会干嘛？  (2_2023_10_30)
创建G的时候会尝试唤醒休眠的M和P组合，这个时候M是运行状态，但是P的本地队列没有G，这个时候M就是自选线程

#### 14. 优先从全局队列偷还是优先从其他本地队列中偷？ (2_2023_10_30)
优先从全局队列偷: n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))
然后从其他本地队列偷: 偷后一半，work stealing


#### 15. 系统中最多有多少个自旋线程？  (2_2023_10_30)
GOMAXPROCS个



参考资料:
1. [ ] [](https://go.cyub.vip/gmp/gmp-model/)
