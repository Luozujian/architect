### GC

#### 1. Go V1.3 标记清除法大概逻辑？ (5_2023_11_22)
1. 第一步，暂停程序业务
2. 第二步，从GC ROOT(堆、当前栈对象)开始，找到所有的可达对象，进行标记
3. 第三步，清除未标记的对象
4. 第四步，开启程序业务


#### 2. 标记清除法的缺点？(5_2023_11_22)
1. 标记需要扫描整个堆、栈, 较长时间的STW，让程序暂停，程序出现卡顿
2. 清除数据会产生内存碎片


#### 3. golang V1.5 三色标级法的大概逻辑？ (5_2023_11_22)
1. 所有对象默认为白色
2. 遍历GC ROOT集合，将其标成灰色
3. 取灰节点集合的对象，将其直接可达对象标记成灰色，然后自己再加入到黑色对象集合
4. 不断重复3步，直到不存在灰色对象集合
5. 回收白色对象

不需要考虑GC期间新创建的对象，因为GC期间创建对象的颜色很好被处理

如果不STW去标记对象会有什么问题呢？ 如果同时满足以下两个条件就可能会导致对象被错误回收

1. 一个白色对象挂在黑色对象下面，
2. 灰色对象删除了对改白色对象的引用

只要破坏这两个条件中的任何一个条件，对象就不会被错误回收，golang研发团队提出了三色不定式，分为强三色不定式和弱三色不定式

强三色不定式: 即黑对象不能直接引用白对象，破坏条件1
弱三色不定式: 即黑对象想要引用白对象，前提是该白色对象的可达链路上必须有灰色对象


基于两个不定式Golang实现了如下两个屏障: 

插入写屏障:  就是强三色不定式的实现，黑对象不能直接引用白对象，如果要引用就将其变成灰色对象，删除写屏障可以解决上述两种问题

删除写屏障:  就是弱三色不定式的实现，删除一个对象，如果其是白色对象，则直接将其置灰

golang v1.5在栈空间实现插入写屏障。

#### 4. 强三色不定式和弱三色不定式的优缺点？  (5_2023_11_22)
插入屏障: 在栈上实现太复杂，结束时需要STW来重新扫描栈，确保不会有对象被错误回收
删除屏障: 精度不够，一个对象被删除了，依然可以活过本轮，要等下一轮才会被删除


#### 5. golang v1.5插入写屏障为何只在堆空间实现？ (5_2023_11_22)
1. 主要是因为栈上实现插入屏障太复杂，做不到 => 栈上寄存器对象赋值无法hook


#### 6. golang v1.8 三色标记法 + 混合写屏障的大概步骤？  (5_2023_11_22)
1. 将栈上所有的可达对象标记成黑的，后续所有在栈上创建的对象都是黑的 => 栈上删除写屏障
2. 堆上删除对象，将被删除对象标记成灰的，添加对象，将被添加对象灰的
3. 从堆上的GC ROOT节点出发，按照三色标级法标记
4. 最后清除白色对象


#### 7. 混合写屏障的优缺点？  (5_2023_11_22)
混合写屏障只在栈上开启还是只能在堆上实现，但是结合对栈上元素的特殊操作


#### 8. 混合写屏障是否还需要STW？ (5_2023_11_22)
在开启屏障和关闭屏障的时候需要有很短暂的STW，保证所有G都运行到安全位置





参考资料:
1. [ ] [一文搞懂go gc垃圾回收原理](https://juejin.cn/post/7111515970669117447)
2. [ ] [详细总结： Golang GC、三色标记、混合写屏障机制 ](https://blog.51cto.com/u_15730090/5510574)
3. [ ] [Runtime: goroutine的暂停和恢复源码剖析](https://blog.haohtml.com/archives/30519)
