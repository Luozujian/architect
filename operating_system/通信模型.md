# 通信模型
#### 1. 什么是虚拟地址？(2_2024_11_12)


#### 1. 什么是用户空间和内核空间？(3_2024_02_19)
用户空间和内核空间是操作系统两种不同的区域，在linux操作系统中，x86架构整个虚拟地址空间是4GB，用户空间占1GB，内核空间占3GB，x86_64架构下，虚拟地址空间非常大，通常用户空间和内核空间都占128T

内核空间: 操作系统内核运行的区域，它负责管理硬件资源，比如网络、磁盘、CPU、内存等，并提供系统调用接口供应用程序访问。该区域只能只能由操作系统内核访问，普通用户程序无法访问。内核代码具有最高权限，也叫特权模式

用户空间: 用户空间是用户程序运行的区域，所有非内核代码都在用户空间执行，操作系统提供系统调用来允许用户程序与内核交互，用户程序在运行在较低程序级别(用户模式)，可以提升系统的安全性和稳定性


#### 2. 用户态切换到内核态开销？ (3_2024_02_19)
1. 用户程序与内核程序上下文信息的保存与恢复
2. 访问不同的内存地址，造成L1、L2缓存失效


#### 2. 进程切换的开销？ (2_2024_02_16)
1. 保存CPU上下文信息，包括程序计数器以及寄存器的相关状态
2. 更新PCB信息并且将该进程加入到相应的队列当中，比如阻塞状态就加入到阻塞队列
3. 加载新进程，更新TLB
4. 恢复新进程上下文信息，使其运行

其中最大的开销在于: 加载新进程，更新TLB，可能会导致很多的缺页中断，使得CPU需要频繁的访问内存，甚至磁盘


#### 3. 了解过几种通信模型？ (2_2024_02_16)
3种，分别是BIO（同步阻塞），NIO（同步非阻塞）以及AIO（异步非阻塞）

BIO: socket调用recev函数获取数据，没有传过期时间，如果数据还没好就会一直阻塞，等待数据准备好，这就是同步阻塞
NIO: socket调用recev函数获取数据，传了时间为0，如果数据没准备好就会立马返回，这就是同步非阻塞
AIO: 线程A进行IO请求，如果数据没有准备好，则立马返回，等数据准备好啦，来通知线程A，A再去做处理

#### 4. 为什么需要IO多路复用？ (2_20241130)
没使用IO多路复用之前，常用的有两种通信模式，BIO和NIO

BIO问题: 建立连接后，需要启动一个新线程监听文件句柄，浪费系统资源
NIO问题：需要不断轮训句柄是否准备就绪，浪费CPU资源
    

#### 5. 什么是IO 多路复用？  (2_2024_02_16)
IO多路复用即允许一个进程/线程监听多个文件描述符，在没有IO多路复用之前，一个进程/线程只能监听一个文件描述符，十分浪费资源。

#### 5. select的实现原理？  (2_2024_02_16)
1.调用select函数，将应用程序关注的文件描述符拷贝到内核态
2.遍历所有文件描述符，将加入到文件描述符的等待队列
3.当有文件描述符准备就绪后，再将应用程序所关注的文件描述符又内核态拷贝到用户态
4.遍历文件描述符，看那个文件描述准备就绪，再进行相应处理


#### 6. select的缺点？  (2_2024_02_16)
问题1: 需要频繁将所文件描述符从用户态拷贝到内核态，从内核态拷贝到用户态，当文件描述符较多时，效率偏低
问题2: 当有文件描述准备就绪时，还需要再遍历一遍，才知道那个文件描述符准备好了
问题3: 限定文件描述符最多1024个

#### 7. poll的实现原理？ (2_2024_02_16)
1. poll的原理和select类似，只不过没有1024的限制。


#### 8. epoll的实现原理？ (2_2024_02_16)
1.调用epoll_create()方法创建一个event_pool对象，event_pool内部包含两个核心数据结构，一个是红黑树，维护文件描述符结合，一个双向链表维护准备就绪的文件描述符
2.然后可以通过epoll_ctl向红黑树中增、删所关心的文件描述符，及其所关注的事件
3.然后可以通过epoll_wait来监听文件描述符
4.文件描述准备就绪后，通过回调函数，将准备就绪的文件描述符及事件加入到双向链表中，返回给应用程序
5.应用程序可直接得到已就绪的文件描述符处理

#### 9. epoll的优点？(2_2024_02_16)
1. 无需频繁将所有关注的文件描述符从用户态拷贝到内核态，从内核态拷贝到用户态
2. O(1)时间就可以得到已准备就绪的文件描述符


#### 9. 什么是ET和LT？  (2_2024_02_16)
LT: 水平触发，当调用epoll_wait检验到有准备就绪的事件，可以不立即处理，下次再次调用epoll_wait的时候，依然可以获取到这部分数据
ET: 边缘触发，当调用epoll_wait检验到有准备就绪的事件，必须及时处理，否则下次再调用epoll_wait将获取不到这部分没有被处理的事件


#### 10. 什么是中断？ (2_2024_02_16)
中断是指CPU因为某些事件停止正在处理程序去处理其他事件的逻辑，处理完成之后继续运行程序的能力。


#### 11. socket对象包含什么？  (2_2024_02_16)
发送缓冲区、接收缓冲区以及等待队列

#### 12. 死锁发生的四个条件？  (2_2024_02_16)
1. 互斥，资源只能被一个进程拥有
2. 请求与保持，请求其他资源并且保持已拥有的资源
3. 循环等待，AB-BA
4. 不可抢占，资源不可被抢占


#### 13. 死锁避免方式？  (2_2024_02_16)
破坏4个条件
1. 为资源编号，获取高优先级的资源，必须先获取到低优先级的资源，如果获取不到，则释放所有资源，破坏请求/保持，循环等待两个条件。


#### 14. 进程间的通信方式？  (2_2024_02_16)
1. pipline，共享内存，信号量
2. socket
3. 消息队列



参考资料：

1. [彻底理解 IO 多路复用实现机制](https://juejin.cn/post/6882984260672847879)






