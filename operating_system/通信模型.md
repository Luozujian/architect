# 通信模型
#### 1. 什么是用户空间和内核空间？(3_2024_02_19)
内核空间: 操作系统的核心功能集合就是内核，运行内核能力的空间就是内核空间。
用户空间: 运行用户程序的空间叫做用户空间

用户空间和内核空间相互独立，用户程序可以按照特定的方式，安全的使用内核功能，这样可以避免用户程序的问题，引起内核功能故障。


#### 2. 进程切换的开销？ (2_2024_02_16)
CPU刮起当前正在执行的进程、去执行另外一个准备就绪的进程

1. 保存CPU上下文信息，包括程序计数器以及寄存器的相关状态
2. 更新PCB信息并且将该进程加入到相应的队列当中，比如阻塞状态就加入到阻塞队列
3. 加载新进程，更新TLB
4. 恢复新进程上下文信息，使其运行

其中最大的开销在于: 加载新进程，更新TLB，可能会导致很多的缺页中断，使得CPU需要频繁的访问内存，甚至磁盘


#### 3. 了解过几种通信模型？ (2_2024_02_16)
3种，分别是BIO（同步阻塞），NIO（同步非阻塞）以及AIO（异步非阻塞）

BIO: socket调用recev函数获取数据，没有传过期时间，如果数据还没好就会一直阻塞，等待数据准备好，这就是同步阻塞
NIO: socket调用recev函数获取数据，传了时间为0，如果数据没准备好就会立马返回，这就是同步非阻塞
AIO: 线程A进行IO请求，如果数据没有准备好，则立马返回，等数据准备好啦，来通知线程A，A再去做处理


#### 4. 什么是IO 多路复用？  (2_2024_02_16)
IO多路复用即允许一个进程/线程监听多个文件描述符，在没有IO多路复用之前，一个进程/线程只能监听一个文件描述符，十分浪费资源。

#### 5. select的实现原理？  (2_2024_02_16)
select需要传递5个参数，分别是文件描述符最大编号，读/写/异常事件的文件描述符以及时间。

他的执行过程大致如下:
1. 将参数由用户态拷贝到内核态
2. 检验是否有文件描述符准备就绪，如果没有则加入到文件描述符的等待队列当中，进入休眠
3. 当有文件描述符准备就绪，则唤醒该线程，然后再扫描一次，将准备就绪的文件描述符由内核态拷贝到用户态

#### 6. select的缺点？  (2_2024_02_16)
1. 每次调用select函数都需要将所关注描述符集合由用户态拷贝到内核态；
2. 并且需要遍历一遍判断是否有文件描述符准备就绪
3. 以及遍历一遍判断将线程加入到文件描述符的等待队列
4. 文件描述符限定最大为1024个


#### 7. poll的实现原理？ (2_2024_02_16)
1. poll的原理和select类似，只不过没有1024的限制。


#### 8. epoll的实现原理？ (2_2024_02_16)
epoll提供三个函数分别是epoll_create、epoll_ctl(增、删、改参数),epoll_wait等待IO事件

1. epoll_crete用于创建epoll对象
2. epoll_ctl增、删、改监听的文件描述符，底层使用黑红树维护（需要高效支持增、删、改操作）优点是只需要添加一次，并且当有事件准备就绪的时候，就直接将文件描述符以及事件加入到就绪队列当中，无需遍历

#### 9. 什么是ET和LT？  (2_2024_02_16)
LT: 边缘触发，当调用epoll_wait检验到有准备就绪的事件，可以不立即处理，下次再次调用epoll_wait的时候，依然可以获取到这部分数据
ET: 边缘触发，当调用epoll_wait检验到有准备就绪的事件，必须及时处理，否则下次再调用epoll_wait将获取不到这部分没有被处理的事件

#### 10. 什么是中断？ (2_2024_02_16)
中断是指CPU因为某些事件停止正在处理程序去处理其他事件的逻辑，处理完成之后继续运行程序的能力。


#### 11. socket对象包含什么？  (2_2024_02_16)
发送缓冲区、接收缓冲区以及等待队列

#### 12. 死锁发生的四个条件？  (2_2024_02_16)
1. 互斥，资源只能被一个进程拥有
2. 请求与保持，请求其他资源并且保持已拥有的资源
3. 循环等待，AB-BA
4. 不可抢占，资源不可被抢占


#### 13. 死锁避免方式？  (2_2024_02_16)
破坏4个条件
1. 为资源编号，获取高优先级的资源，必须先获取到低优先级的资源，如果获取不到，则释放所有资源，破坏请求/保持，循环等待两个条件。


#### 14. 进程间的通信方式？  (2_2024_02_16)
1. pipline，共享内存，信号量
2. socket
3. 消息队列







