### 1.基础语法

##### 1.1 new和make的区别？(3_2023_09_13)
new: new可以为任意类型的变量分配内存空间，并且返回一个相应类型的指针，不会进行初始化动作
make: make只可以为map、slice以及channel分配内存，返回相应类型的引用，并做初始化动作

##### 1.2 什么是指针，什么是引用？(3_2023_09_13)
指针: 指向一个变量的地址，后续可以指向新地址
引用: 指向一个变量的地址，无法让其指向新地址

[c语言中引用和指针的区别]([url](https://www.php.cn/be/go/439923.html)https://www.php.cn/be/go/439923.html)
```c
int a= 2,b = 3;
int *ptr = &a, &ptry = b;
ptry = a;
printf("%d %d %d\n",*ptr,ptry,b);
output:
    2 2 2
```
##### 1.3 什么是值类型，什么是引用类型？(3_2023_09_13)
值类型: 值类型变量存储的是具体的值，例如golang int、string、float，bool类型
引用类型: 引用类型变量存储的值的地址，例如map、slice、channel

还有一个特殊类型: interface，这个就是其原类型是值类型，那么该interface就也是值类型，如果其原类型是引用类型，那么其就也是引用类型

```c++
golang传指针，单个变量，需用 *a = b 去修改指针的值，而结构体，可直接修改

func PointTest1(a *int) {
	b := 1
	*a = b
}

func StructTest1(s *Student) {
	s.Name = "123"
}
 
```

##### 1.4 什么是深拷贝，什么是浅拷贝？(3_2023_09_13)
深拷贝：指复制出来一个新对象，新对象拥有自己的内存地址和原对象不贡献共存地址，golang值类型的复制都是深拷贝
浅拷贝: 指复制出来一个新指针或者引用，该指针或者引用指向原对象内存地址

调用一个函数传值则是深拷贝，传指针或者引用则是浅拷贝

##### 1.5 golang切片和数组的区别？(2_2023_09_13)
数组: 维护同一种类型数据的集合，长度不可变，值类型
切片: 维护同一种类型数据的集合，长度可变，引用类型，其底层由数组实现，并且还比数组多了一个cap的概念


##### 1.6 切片的扩容机制？(2_2023_09_13)
golang1.18版本之前的扩容机制:
1.如果所需容量大于原来容量的两倍，则直接扩容到所需容量
2.如果原长度小于1024，则直接扩容为原容量的两倍
3.如果原长度大于1024，每次扩容原容量的125%，直到满足所需容量

最后得到新容量之后，还会做内存对齐，最终得到的扩容容量会大于或者等于计算出来的容量

golang1.18版本之后的扩容机制:
1.如果所需容量大于原始容量的两倍，则直接扩容到所需容量
2.如果原始容量小于 threshold (256),则直接扩容到两倍
3.如果原始容量大于 threshold (256),会有一个1.25 ~ 2之间的动态扩容系数，每次扩容扩扩容系数的倍数，知道满足所需容量

优点:
1.原始容量小，则快扩容，原始容量大，则慢扩容

<img width="496" alt="image" src="https://github.com/Luozujian/architect/assets/27532970/18515cb3-3bb5-4f46-9136-00f5c45788a7">
<img width="608" alt="image" src="https://github.com/Luozujian/architect/assets/27532970/e6ed5564-0ec8-4718-8853-8e2e5d7dc520">


##### 1.7 切片扩容所引发的问题？ (2_2023_09_13)
调用函数传切片，如果切片发生了扩容，函数内切片的指针会指向一个新的切片。具体pointA -> objectA, 函数内pointB -> objectA，函数内发生扩容pointB -> objectB。

如果没发生扩容: 引用类型
发生扩容: 值类型

参考资料:
1. [ ] [1.扩容机制](https://juejin.cn/post/7101928883280150558)

##### 1.8 什么是内存逃逸? (2_2023_09_13)
内存逃逸指的是原来应该在栈上分配的内存，经过逃逸分析之后到堆上分配了，c语言中函数无法返回局部变量的地址，因为局部变量是在栈中分配内存的，随便函数执行完，栈中分配的内存都会被
回收，那么在访问原来的地址就是非法访问了。但是golang中可以，因为在编译器期经过逃逸分析之后，会在堆上给变量分配内存空间。

为什么要有逃逸分析: c++支持直接使用malloc 和 new函数在堆上分配内存，需要使用者自己销毁，而golang简化了使用者的操作，你就随便使用，变量分配在堆上还是栈上，让逃逸分析来决定

常见内存逃逸情况:
1. 函数返回局部变量引用
2. 函数返回闭包
3. 栈空间不足

优点:
1. 避免内存泄露
2. 减轻GC压力，栈用完即回收，堆需要GC回收
3. 提升程序效率，栈上分配内存比堆上分配内存更快

参考资料:
1. [ ] [1.内存逃逸](https://learnku.com/articles/67151)

##### 1.9 传值还是传指针？(2_2023_09_13)
传值会发生深拷贝，传指针可能会导致内存逃逸增加GC压力，为避免在对象平凡创建于删除的场景给GC带来太大的压力，影响程序性能，我一般是选择在对象比较大的时候或者希望该对象
被下游修改的时候传指针，其余传结构体。

什么叫大，什么叫小？

##### 1.10 golang一般什么时候会panic? (2_2023_09_13)
1. 空指针
2. 数组越界
3. 类型断言失败
4. 关闭未初始化的channel，重复关闭channel，向以关闭的channel发送数据
5. 死锁，所有线程睡眠(向通道发送数据，但是没有线程去接受)
6. 未初始化的map赋值
7. 并发的读写map
8. 递归死循环堆栈溢出







